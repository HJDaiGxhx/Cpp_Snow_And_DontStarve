#pragma once

#include "BTNode.h"

/* 重点只有两个——1，从二叉树转变为使用多叉树；2，这个多叉树的孩子个数在m/2上入~m之间，且都是连续存放的。

原理——当数据非常多的时候，虽然理论上还能使用BBST，但数据结构毕竟不是纯数学，而和计算机相结合，因此内外存的效率问题使得BBST出现问题。

因为二叉树都是用指针来存储lc、rc的，因此使用二叉查找时，只能让处理器通过指针提前取来这两个，甚至是取来lc、lc的孩子和rc、rc的孩子，甚至孙子。当数据有10^9个字节时，树高大致为30，那么就需要30次外存的读取（分布在外存的各个地方？或者按照向量等价转化，现在的二叉树是层次遍历的，是横向一排取到内存，或者通过算式n/2-1是lc这种，总之就是不连续存放），即使流水线提前取孩子孙子，无效的数据2倍2倍地增长极快，效率的提升并没有飞跃。

因为没有利用到存储器天生的长处——批量存取，取一个字节和取地址连续的N个字节都只耗时同一时刻，而B-树就是对此的改良——它在我眼中其实和多叉树相差无几，顶多它的分支在m/2上入~m之间，比多叉树更稳定。

#N 甚至换言之，可以理解为存储器天生就喜欢向量形式的内容，因为它擅长这么读取，但人们又需要高级数据结构，因此这又是一种“翻译”，无法调和，只能通过编写函数来转换图、二叉树为向量……？

文件的存储好像多使用这种结构，就是因为其内容极大，它有另一个名字叫索引结构。*/
template <typename T>
class BTree
{
private:
    int _size;
    int _order;
    BTNodePosi<T> _root;
    BTNodePosi<T> _hot;
    void solveOverFlow(BTNodePosi<T>);
    void solveUnderFlow(BTNodePosi<T>);

public:
};